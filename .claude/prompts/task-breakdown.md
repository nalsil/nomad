# Task Breakdown Prompt Template

## 📝 사용법
큰 작업을 체계적으로 분해하여 실행 가능한 작은 단위로 만듭니다.

## 🎯 입력 형식

```markdown
### 프로젝트 목표
[최종 달성하고자 하는 목표를 명확히 기술]

### 현재 상태
- 기존 코드베이스: [설명]
- 사용 기술 스택: [나열]
- 제약사항: [나열]

### 요구사항
1. [기능 요구사항 1]
2. [기능 요구사항 2]
3. [비기능 요구사항 - 성능, 보안 등]

### 우선순위
- 필수(Must Have): [나열]
- 중요(Should Have): [나열]
- 선택(Nice to Have): [나열]
```

## 🔧 분해 프레임워크

### Phase 1: 목표 분석
1. **목표를 3-5개 핵심 기능으로 분해**
   - 각 기능이 독립적으로 가치를 제공하는지 확인
   - INVEST 원칙 적용 (Independent, Negotiable, Valuable, Estimable, Small, Testable)

### Phase 2: 작업 단위 정의
2. **각 기능을 실행 가능한 작업으로 세분화**

   각 작업은 다음을 포함:
   ```markdown
   - [ ] **작업명**: [간결하고 명확한 이름]
     - **설명**: [무엇을, 왜 해야 하는지]
     - **범위**: [포함되는 것 / 제외되는 것]
     - **완료 조건**: [측정 가능한 기준]
     - **예상 시간**: [1-4시간 단위]
     - **의존성**: [선행 작업 나열]
     - **리스크**: [예상되는 문제점]
     - **검증 방법**: [어떻게 확인할지]
   ```

### Phase 3: 우선순위와 순서
3. **작업 실행 순서 결정**

   고려사항:
   - 의존성 그래프 (선행 작업 우선)
   - 리스크 관리 (불확실한 작업 먼저)
   - 가치 전달 (MVP 기능 우선)
   - 학습 곡선 (간단한 것부터 시작)

### Phase 4: 검증 계획
4. **각 단계별 검증 방법 정의**

   ```markdown
   - 단위 테스트: [무엇을 테스트할지]
   - 통합 테스트: [어떤 시나리오]
   - 수동 확인: [체크리스트]
   - 성능 기준: [측정 지표]
   ```

## 📊 출력 형식

### 요약 테이블
```markdown
| Phase | 작업 | 우선순위 | 예상시간 | 의존성 | 상태 |
|-------|------|----------|----------|--------|------|
| 1     | ... | 높음     | 2h       | 없음   | ⬜   |
```

### 상세 작업 분해
```markdown
## Phase 1: [단계명]

### 목표
[이 단계에서 달성할 것]

### 작업 리스트
- [ ] **작업 1.1**: [설명]
  - 완료 조건: [기준]
  - 예상 시간: [시간]
  - 검증: [방법]

- [ ] **작업 1.2**: [설명]
  - 의존성: 작업 1.1
  - 완료 조건: [기준]

### 검증 기준
- [ ] [검증 항목 1]
- [ ] [검증 항목 2]
```

## 🎯 작업 크기 가이드

### 적절한 작업 크기
- **Small (1-2시간)**: 단일 컴포넌트, 단순 기능
- **Medium (2-4시간)**: 복합 기능, 여러 파일 수정
- **Large (4-8시간)**: 복잡한 기능, 아키텍처 변경
- **Too Large (>8시간)**: 더 작게 분해 필요!

### 분해 시그널
작업이 너무 큰 경우:
- "그리고" 또는 "또한"이 설명에 많이 등장
- 3개 이상의 파일을 동시에 수정
- 여러 도메인/레이어를 넘나듦
- 예상 시간이 불확실함

## 🔄 반복 개선

### 회고 질문
1. 예상 시간과 실제 시간 차이는?
2. 어떤 작업이 예상보다 복잡했나?
3. 의존성을 놓친 부분은?
4. 다음에는 어떻게 개선할까?

## 💡 실전 팁

### DO ✅
- 작은 단위로 나누기 (1-4시간)
- 측정 가능한 완료 조건 설정
- 의존성 명확히 하기
- 검증 방법 미리 정의
- 우선순위 명확히 하기

### DON'T ❌
- 너무 추상적인 작업 정의
- 완료 조건 없이 진행
- 의존성 무시하고 병렬 시도
- 검증 계획 없이 구현만 진행
- 모든 작업을 동시에 시작

## 🚀 예시: 로그인 기능 추가

### 나쁜 예 ❌
```markdown
- [ ] 로그인 기능 구현
```

### 좋은 예 ✅
```markdown
## Phase 1: 인증 기반 구축
- [ ] **Supabase Auth 설정**
  - 완료 조건: 환경변수 설정, 클라이언트 초기화 코드 작성
  - 예상 시간: 1시간
  - 검증: 연결 테스트 성공

## Phase 2: UI 구현
- [ ] **로그인 폼 컴포넌트 생성**
  - 의존성: Phase 1 완료
  - 완료 조건: 이메일/비밀번호 입력, 유효성 검사
  - 예상 시간: 2시간
  - 검증: Storybook에서 확인

## Phase 3: 통합
- [ ] **로그인 로직 구현**
  - 의존성: Phase 2 완료
  - 완료 조건: Supabase 인증 호출, 에러 처리
  - 예상 시간: 2시간
  - 검증: E2E 테스트 작성 및 통과
```

## 🎓 고급 기법

### 1. Story Mapping
사용자 여정을 기반으로 작업 분해:
```
사용자 목표 → 단계 → 작업 → 세부 작업
```

### 2. Walking Skeleton
엔드투엔드로 가장 단순한 버전 먼저 구현:
```
최소 기능 → 점진적 개선 → 완성
```

### 3. Risk-First Approach
가장 불확실한 부분을 먼저 해결:
```
높은 리스크 작업 → 검증 → 안정적 작업 진행
```

---

## 📚 체크리스트

프롬프트 사용 전:
- [ ] 최종 목표가 명확한가?
- [ ] 현재 상태를 파악했는가?
- [ ] 제약사항을 고려했는가?
- [ ] 우선순위가 정해졌는가?

작업 분해 후:
- [ ] 각 작업이 1-4시간 내인가?
- [ ] 완료 조건이 측정 가능한가?
- [ ] 의존성이 명확한가?
- [ ] 검증 방법이 정의되었는가?
- [ ] 실행 순서가 논리적인가?
